import {
    Entity,
    PrimaryGeneratedColumn,
    Column,
    CreateDateColumn,
    UpdateDateColumn,
    ManyToOne,
    JoinColumn,
    Index,
} from 'typeorm';
import { User } from './User';

export enum ApplicationType {
    GENERAL_SOCIETY = 'general_society',
    BURIAL_SOCIETY = 'burial_society',
    RELIGIOUS_SOCIETY = 'religious_society',
    SACCOS = 'saccos',
}

export enum ApplicationStatus {
    DRAFT = 'draft',
    SUBMITTED = 'submitted',
    INCOMPLETE = 'incomplete',
    UNDER_REVIEW = 'under_review',
    SECURITY_VETTING = 'security_vetting',
    SECURITY_FAILED = 'security_failed',
    LEGAL_REVIEW = 'legal_review',
    LEGAL_REJECTED = 'legal_rejected',
    PENDING_DECISION = 'pending_decision',
    APPROVED = 'approved',
    REJECTED = 'rejected',
    APPEAL_LODGED = 'appeal_lodged',
    APPEAL_APPROVED = 'appeal_approved',
    APPEAL_REJECTED = 'appeal_rejected',
}

@Entity('society_applications')
@Index(['fileNumber'], { unique: true, where: 'file_number IS NOT NULL' })
@Index(['proposedName'])
@Index(['status'])
export class SocietyApplication {
    @PrimaryGeneratedColumn('uuid')
    id!: string;

    @Column({ nullable: true, unique: true })
    fileNumber?: string; // Auto-generated by Registry Clerk (e.g., GS-2026-001)

    @Column({ type: 'enum', enum: ApplicationType })
    applicationType!: ApplicationType;

    @Column()
    proposedName!: string;

    @Column({ type: 'enum', enum: ApplicationStatus, default: ApplicationStatus.DRAFT })
    status!: ApplicationStatus;

    // Applicant info
    @Column({ type: 'uuid' })
    applicantUserId!: string;

    @ManyToOne(() => User)
    @JoinColumn({ name: 'applicantUserId' })
    applicant?: User;

    @Column()
    primaryContactName!: string;

    @Column()
    primaryContactEmail!: string;

    @Column()
    primaryContactPhone!: string;

    @Column({ type: 'text' })
    physicalAddress!: string;

    // Workflow tracking
    @Column({ type: 'timestamp', nullable: true })
    submittedAt?: Date;

    @Column({ type: 'timestamp', nullable: true })
    assignedFileNumberAt?: Date;

    @Column({ type: 'timestamp', nullable: true })
    securityClearedAt?: Date;

    @Column({ type: 'timestamp', nullable: true })
    legalApprovedAt?: Date;

    @Column({ type: 'timestamp', nullable: true })
    finalDecisionAt?: Date;

    @Column({ type: 'text', nullable: true })
    securityVettingNotes?: string;

    // Decision makers
    @Column({ type: 'uuid', nullable: true })
    registryClerkId?: string;

    @ManyToOne(() => User)
    @JoinColumn({ name: 'registryClerkId' })
    registryClerk?: User;

    @Column({ type: 'uuid', nullable: true })
    intelligenceLiaisonId?: string;

    @ManyToOne(() => User)
    @JoinColumn({ name: 'intelligenceLiaisonId' })
    intelligenceLiaison?: User;

    @Column({ type: 'uuid', nullable: true })
    legalOfficerId?: string;

    @ManyToOne(() => User)
    @JoinColumn({ name: 'legalOfficerId' })
    legalOfficer?: User;

    @Column({ type: 'uuid', nullable: true })
    finalDecisionMakerId?: string; // Registrar or Director

    @ManyToOne(() => User)
    @JoinColumn({ name: 'finalDecisionMakerId' })
    finalDecisionMaker?: User;

    // Outcomes
    @Column({ nullable: true })
    certificateNumber?: string;

    @Column({ type: 'timestamp', nullable: true })
    certificateIssuedAt?: Date;

    @Column({ type: 'text', nullable: true })
    rejectionReasons?: string;

    // Appeal
    @Column({ type: 'timestamp', nullable: true })
    appealLodgedAt?: Date;

    @Column({ type: 'timestamp', nullable: true })
    appealDecisionAt?: Date;

    @Column({ type: 'uuid', nullable: true })
    appealDecisionMakerId?: string;

    @ManyToOne(() => User)
    @JoinColumn({ name: 'appealDecisionMakerId' })
    appealDecisionMaker?: User;

    @Column({ type: 'text', nullable: true })
    appealOutcome?: string;

    // Fees
    @Column({ type: 'decimal', precision: 10, scale: 2, default: 0 })
    feeAmount!: number;

    @Column({ type: 'timestamp', nullable: true })
    feePaidAt?: Date;

    @CreateDateColumn()
    createdAt!: Date;

    @UpdateDateColumn()
    updatedAt!: Date;

    // Helper methods
    get isApproved(): boolean {
        return this.status === ApplicationStatus.APPROVED || this.status === ApplicationStatus.APPEAL_APPROVED;
    }

    get isRejected(): boolean {
        return this.status === ApplicationStatus.REJECTED ||
            this.status === ApplicationStatus.SECURITY_FAILED ||
            this.status === ApplicationStatus.LEGAL_REJECTED ||
            this.status === ApplicationStatus.APPEAL_REJECTED;
    }

    get canAppeal(): boolean {
        if (!this.isRejected || this.status === ApplicationStatus.APPEAL_REJECTED) {
            return false;
        }

        // Check if within 21 days of rejection
        const rejectionDate = this.finalDecisionAt;
        if (!rejectionDate) return false;

        const now = new Date();
        const daysSinceRejection = Math.floor((now.getTime() - rejectionDate.getTime()) / (1000 * 60 * 60 * 24));

        return daysSinceRejection <= 21;
    }

    get requiredFee(): number {
        // If a specific fee amount was set at creation/approval time, use that
        if (this.feeAmount && Number(this.feeAmount) > 0) {
            return Number(this.feeAmount);
        }

        // Fallback for draft/legacy applications
        switch (this.applicationType) {
            case ApplicationType.RELIGIOUS_SOCIETY:
                return 500; // BWP 500 for churches
            case ApplicationType.SACCOS:
                return 20; // BWP 20 for SACCOS
            case ApplicationType.GENERAL_SOCIETY:
            case ApplicationType.BURIAL_SOCIETY:
            default:
                return 250; // BWP 250 for general societies
        }
    }

    get isPaid(): boolean {
        return this.feePaidAt !== null && this.feeAmount >= this.requiredFee;
    }
}
